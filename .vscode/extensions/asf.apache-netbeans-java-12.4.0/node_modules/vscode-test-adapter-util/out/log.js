"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const vscode = require("vscode");
const util = require("util");
/**
 * A simple logger for VS Code extensions that can log to a VS Code output channel or a file
 */
class Log {
    /**
     * Create a simple logger for VS Code extensions that can log to a VS Code output channel or a file
     * @param configSection - the prefix for the configuration variables: logging to the output channel will be enabled if <configSection>.logpanel is set to true, logging to a file will be enabled if <configSection>.logfile is set to a filename
     * @param workspaceFolder - the WorkspaceFolder (optional)
     * @param outputChannelName - the name of the output channel
     * @param includeLocation - if true it will try to include the location info of the caller
     */
    constructor(configSection, workspaceFolder, outputChannelName, inspectOptions = {}, includeLocation = false) {
        this.configSection = configSection;
        this.workspaceFolder = workspaceFolder;
        this.outputChannelName = outputChannelName;
        this.inspectOptions = inspectOptions;
        this.includeLocation = includeLocation;
        this.targets = [];
        this.nextInspectOptions = undefined;
        this.configure();
        this.configChangeSubscription = vscode.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration(this.configSection + '.logpanel') ||
                event.affectsConfiguration(this.configSection + '.logfile')) {
                this.configure();
            }
        });
    }
    get enabled() { return (this.targets.length > 0); }
    setDefaultInspectOptions(inspectOptions) {
        this.inspectOptions = inspectOptions;
    }
    updateDefaultInspectOptions(inspectOptions) {
        Object.assign(this.inspectOptions, inspectOptions);
    }
    setNextInspectOptions(inspectOptions) {
        this.nextInspectOptions = inspectOptions;
    }
    updateNextInspectOptions(inspectOptions) {
        if (this.nextInspectOptions !== undefined)
            Object.assign(this.nextInspectOptions, inspectOptions);
        else
            this.nextInspectOptions = Object.assign(Object.assign({}, this.inspectOptions), inspectOptions);
    }
    debug(...msg) {
        this.log('DEBUG', msg);
    }
    info(...msg) {
        this.log('INFO', msg);
    }
    warn(...msg) {
        this.log('WARN', msg);
    }
    error(...msg) {
        this.log('ERROR', msg);
    }
    dispose() {
        if (this.configChangeSubscription) {
            this.configChangeSubscription.dispose();
            this.configChangeSubscription = undefined;
        }
        this.targets.forEach(target => target.dispose());
        this.targets = [];
    }
    log(logLevel, msg) {
        if (this.targets.length > 0) {
            const dateString = new Date().toISOString().replace('T', ' ').replace('Z', '');
            let prefix = `[${dateString}] [${logLevel}] `;
            if (this.includeLocation) {
                const loc = this.getCallerLocation();
                if (loc)
                    prefix += `[${loc}] `;
            }
            const inspectOptions = this.nextInspectOptions !== undefined
                ? this.nextInspectOptions
                : this.inspectOptions;
            let isPreviousNotString = false;
            for (let i = 0; i < msg.length; ++i) {
                try {
                    if (typeof msg[i] !== 'string') {
                        msg[i] = util.inspect(msg[i], inspectOptions)
                            + (isPreviousNotString ? ';' : '');
                        isPreviousNotString = true;
                    }
                    else {
                        isPreviousNotString = false;
                    }
                }
                catch (e) {
                    msg[i] = '<inspection error>';
                }
            }
            const logEntry = prefix + msg.join(' ');
            this.targets.forEach(target => target.write(logEntry));
        }
        this.nextInspectOptions = undefined;
    }
    getCallerLocation() {
        try {
            const err = Error();
            // stack: 'This feature is non-standard and is not on a standards track.'
            if (!err.stack || typeof err.stack !== 'string')
                return undefined;
            let lastCurrentFile = err.stack.lastIndexOf(__filename);
            if (lastCurrentFile === -1) {
                lastCurrentFile = err.stack.lastIndexOf(path.basename(__filename));
                if (lastCurrentFile === -1)
                    return undefined;
            }
            const newLine = err.stack.indexOf('\n', lastCurrentFile);
            if (newLine === -1)
                return undefined;
            let nextNewLine = err.stack.indexOf('\n', newLine + 1);
            if (nextNewLine === -1)
                nextNewLine = err.stack.length;
            return err.stack.substring(newLine + 1, nextNewLine).trim();
        }
        catch (e) {
            return undefined;
        }
    }
    configure() {
        this.targets.forEach(target => target.dispose());
        this.targets = [];
        const uri = this.workspaceFolder ? this.workspaceFolder.uri : null;
        const configuration = vscode.workspace.getConfiguration(this.configSection, uri);
        if (configuration.get('logpanel')) {
            this.targets.push(new OutputChannelTarget(this.outputChannelName));
        }
        const file = configuration.get('logfile');
        if (file) {
            try {
                this.targets.push(new FileTarget(file));
            }
            catch (err) {
                vscode.window.showErrorMessage(`Couldn't open log file ${file}: ${err}`);
            }
        }
    }
}
exports.Log = Log;
class OutputChannelTarget {
    constructor(name) {
        this.outputChannel = vscode.window.createOutputChannel(name);
    }
    write(msg) {
        this.outputChannel.appendLine(msg);
    }
    dispose() {
        this.outputChannel.dispose();
    }
}
exports.OutputChannelTarget = OutputChannelTarget;
class FileTarget {
    constructor(filename) {
        this.writeStream = fs.createWriteStream(filename, { flags: 'a' });
        this.writeStream.on('error', (err) => {
            vscode.window.showErrorMessage(`Couldn't write log file ${filename}: ${err}`);
        });
    }
    write(msg) {
        this.writeStream.write(msg + '\n');
    }
    dispose() {
        this.writeStream.end();
    }
}
exports.FileTarget = FileTarget;
